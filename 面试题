1、Android 内存管理机制：
     系统有一个规则来回收内存，进行内存调度有个阈值，只有低于这个值系统才会按一个列表来关闭用户不需要的东西。
     在内存剩余不多时打开大型应用时会触发系统自身的进程调度策略，这是十分消耗系统资源的操作，特别是在一个程序频繁向系统申请内存的时候。这种情况下系统并不会关闭所有打开的进程，而是选择性关闭，频繁的调度自然会拖慢系统。
     选择性关闭自然就会有进程的优先级用于判断那些进程可以关闭。
     判断那些进程需要关闭，关闭进程这些都是耗时的操作。
     
内存管理的另一个机制是对进程的管理   -->  进程的分类：
  - 前台进程：目前正在屏幕上显示的进程和一些系统进程。
  - 可见进程：是一些不在前台，但用户仍然可见的进程，比如widget、输入法等。
  - 次要服务：目前正在运行的一些服务（主要服务，如拨号、短信等。）
  - 后台进程：启动后，被切换到后台的进程。
  - 内容供应节点：没有程序实体，仅提供内容供别的程序使用。
  - 空进程： 没有任何东西在内运行的进程，作用是提高该程序下次的启动速度

2、Android 绘制原理：
     Android应用程序调用SurfaceFlinger服务把经过测量、布局和绘制后的Surface渲染到显示屏幕上。
     Android应用程序的显示过程包含了两个部分（应用侧绘制，系统侧绘制）、两个机制（进程间通信机制，显示刷新机制）
     应用侧绘制：
           android应用程序的窗口UI是由各个View组成，开始绘制之前需要对这些view进行measure, layout, draw的操作。
     系统侧绘制：
           在执行完应用侧的绘制之后ViewRoot会把这些绘制的数据保存在图形缓冲区里面等待SurfaceFlinger进行绘制操作。
     进程间通信机制：
           Android应用程序与SurfaceFlinger服务是运行在不同的进程中的，因此它们采用进程间通信机制来进行通信。还有就是view的绘制包含很多数
           据，单单使用进程间通信无法满足传递大量数据的需求，所以它们之间又通过android的匿名共享内存来传递UI数据。
     显示刷新机制：
           一般我们在绘制UI的时候，都会采用一种称为“双缓冲”的技术。双缓冲意味着要使用两个缓冲区，其中一个是Front Buffer， 另一个是Back
           Buffer。绘制时，会交替从这两个缓冲区里面获取绘制的UI数据。理想情况下，人眼看到时不会有卡顿的效果，这样一个刷新操作需要在16ms内完
           成（60帧）。



